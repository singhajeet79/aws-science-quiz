# AWS Science Quiz Starter

Starter repo for a 10-question online science quiz hosted on AWS (free tier friendly).

## Structure
- backend/: Lambda function code (Python)
- frontend/: HTML/JS quiz UI
- infrastructure/: CloudFormation/SAM template


### (1) Frontend (S3 + CloudFront)
1- Build a small static JS app that:
   - lets each student enter school code + roll number (or Cognito sign-in).
   - shows 10 questions, one page.
   - posts answers to /submit endpoint (API Gateway).
   - shows final score after submission (optionally calculated on server).

2- Host build on an S3 bucket configured for static website hosting (or host behind CloudFront for HTTPS).\
3- Create CloudFront distribution with the S3 bucket as origin; enable HTTPS and set cache rules (no caching for API calls — only static assets). CloudFront has free tier allowances; still good to use for performance. 

### (2) Backend APIs (API Gateway + Lambda)
1- Design minimal APIs:
   - POST /start → create a session, optionally assign a time window or token. (Lambda: create session item in DynamoDB and return session token.)
   - GET /questions → returns the 10 questions for a valid session token.
   - POST /submit → submit answers; Lambda validates token, stores answers, computes score (or do score later).
   - GET /result/{sessionId} → (optional) return result.

2- Implementation choices:
   - Use HTTP API (cheaper) unless you need REST features.
   - Authorize via Cognito JWT tokens, or use simple bearer tokens generated by /start (short-lived, e.g., 15 mins) to keep things simple.

### (3) Database (DynamoDB)
One table ExamResponses:
   - PK: schoolId#sessionId or sessionId
   - Sort key: timestamp or studentId
     Attributes: answers (JSON), score, submitTime, metadata (school/class/grade).

Another table Questions:
   - PK: examId (e.g., science-grade6-2025)
   - store questions + choices + correct answers (or store correct answers encrypted / in separate table only for scoring function).

Use on-demand mode to avoid capacity provisioning for the one-time event. Smaller item sizes reduce costs.

### (4) Authentication / Student identity
Options:
   - Simplest: pre-issue school codes + student roll numbers; frontend asks for school code + roll number; backend verifies against a simple CSV / DynamoDB table of valid students. Good if you already have a list per school.
   - Stronger: use Cognito user pool and pre-create users (or self-sign up with verification). Cognito free tier often covers tens of thousands MAUs for Lite/Essentials tiers — check current quotas for your account.

### (5) Deployment / IaC
   - Use AWS SAM or Serverless Framework or Terraform in infra/. SAM is great for Lambda + API Gateway + DynamoDB as a single deployable template.
   - Create IAM roles for Lambda with least privilege (DynamoDB: PutItem/GetItem only for the specific table).

### (6) CI/CD: GitHub Actions
   - On push to main, build frontend, run tests, then:
    - upload frontend build to S3 (invalidate CloudFront after deploy).
    - deploy SAM/CloudFormation (aws cloudformation deploy) or sam deploy.
   - Use GitHub secrets for AWS credentials (IAM user with programmatic access and limited deploy permissions).

### (7) Monitoring & Logs
   - Use CloudWatch Logs for Lambda and API Gateway logs. Set retention and create CloudWatch Alarms for errors or throttling.
   - Keep an eye on CloudWatch metrics for DynamoDB throttling and Lambda errors.
   - Enable X-Ray if you want distributed tracing for debugging.

### (8) Testing
   - Dry run with smaller groups (e.g., 50–200 users) to capture performance and tweak concurrency setting, retry logic, and DynamoDB consistency.
   - Use a load test tool (k6 or Artillery) to simulate concurrent post requests. Test on a staging account first.

### (9) Cost control & safety
   - Turn on billing alarms (AWS Budgets) to avoid surprises. For a mostly serverless short event costs can be low — but watch data transfer and Lambda execution time. New accounts often get credits.
